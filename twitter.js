// Generated by CoffeeScript 1.10.0
(function() {
  var Queue, Surveyer, Twit, assert, authenticate, co, coRedis, createRedisClient, influential, limits, parseOptionalInt, rateLimiter, redis, start, untilSignal, util,
    slice = [].slice,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  assert = require('assert');

  util = require('util');

  co = require('co');

  redis = require('redis');

  coRedis = require('co-redis');

  limits = require('co-limits');

  Twit = require('twit');

  influential = 4950;

  untilSignal = function*(signal) {
    var forever;
    if (signal == null) {
      signal = 'SIGTERM';
    }
    forever = null;
    process.on(signal, function() {
      return clearTimeout(forever);
    });
    return (yield function(cb) {
      return forever = setTimeout(cb, 2147483647);
    });
  };

  parseOptionalInt = function(n) {
    n = parseInt(n);
    if (isNaN(n)) {
      n = void 0;
    }
    return n;
  };

  createRedisClient = function() {
    return coRedis(redis.createClient(process.env.REDIS_URL));
  };

  Queue = (function() {
    function Queue(queueName, arg) {
      var ref;
      this.queueName = queueName;
      ref = arg != null ? arg : {}, this.pushedCap = ref.pushedCap, this.queueCap = ref.queueCap;
      this.redis = createRedisClient();
      this.blockingRedis = void 0;
    }

    Queue.prototype.push = function*(value) {
      if ((this.pushedCap != null) && (this.pushedCap < (yield this.redis.scard(this.queueName + "-pushed")))) {
        (yield this.redis.spop(this.queueName + "-pushed"));
        (yield this.redis.spop(this.queueName + "-pushed"));
        (yield this.redis.incrby(this.queueName + "-discarded", 2));
      }
      if ((this.queueCap != null) && (this.queueCap < (yield this.redis.llen(this.queueName + "-queue")))) {
        (yield this.redis.incr(this.queueName + "-discarded"));
        return;
      }
      if (!(yield this.redis.sadd(this.queueName + "-pushed", value))) {
        return;
      }
      return (yield this.redis.rpush(this.queueName + "-queue", value));
    };

    Queue.prototype.pop = function*(timeout) {
      var _, ref, value;
      if (timeout === 0) {
        value = (yield this.redis.lpop(this.queueName + "-queue"));
      } else {
        if (this.blockingRedis == null) {
          this.blockingRedis = createRedisClient();
        }
        ref = (yield this.blockingRedis.blpop(this.queueName + "-queue", timeout != null ? timeout : 0)), _ = ref[0], value = ref[1];
      }
      (yield this.redis.incr(this.queueName + "-popped"));
      return value;
    };

    Queue.prototype.stats = function*() {
      return {
        pushed: (yield this.redis.scard(this.queueName + "-pushed")),
        popped: (yield this.redis.get(this.queueName + "-popped")),
        queue: (yield this.redis.llen(this.queueName + "-queue")),
        discarded: (yield this.redis.get(this.queueName + "-discarded"))
      };
    };

    return Queue;

  })();

  rateLimiter = function(options) {
    var disciplinaryNaptime, f, now, ref, ref1, ref2, voluntaryNaptime, waitUntil;
    ref = options || {}, disciplinaryNaptime = (ref1 = ref.disciplinaryNaptime) != null ? ref1 : 60000, voluntaryNaptime = (ref2 = ref.voluntaryNaptime) != null ? ref2 : 0;
    waitUntil = 0;
    now = function() {
      return new Date().getTime();
    };
    f = function*(fn) {
      var data, delay, ref3, response;
      delay = waitUntil - now();
      if (delay > 0) {
        (yield (function(cb) {
          return setTimeout(cb, delay);
        }));
      }
      ref3 = (yield function(cb) {
        return fn(function() {
          var args, err;
          err = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          return cb.apply(null, [null].concat(slice.call(args)));
        });
      }), data = ref3[0], response = ref3[1];
      waitUntil = voluntaryNaptime + now();
      if ((response != null ? response.headers['x-rate-limit-remaining'] : void 0) === '0') {
        waitUntil = Math.max(waitUntil, 1000 * parseInt(response.headers['x-rate-limit-reset']));
      }
      if ((response != null ? response.statusCode : void 0) === 429) {
        waitUntil = Math.max(waitUntil, disciplinaryNaptime + now());
        (yield f(fn));
      }
      return [data, response];
    };
    return f;
  };

  Surveyer = (function() {
    function Surveyer(twitter1) {
      var pushedCap, queueCap;
      this.twitter = twitter1 != null ? twitter1 : null;
      this.friends = bind(this.friends, this);
      this.followers = bind(this.followers, this);
      this.users = bind(this.users, this);
      this.seed = bind(this.seed, this);
      pushedCap = parseOptionalInt(process.env.USER_PUSHED_CAP);
      queueCap = parseOptionalInt(process.env.USER_QUEUE_CAP);
      this.userQueue = new Queue('user', {
        pushedCap: pushedCap,
        queueCap: queueCap
      });
      pushedCap = parseOptionalInt(process.env.FOLLOWERS_PUSHED_CAP);
      queueCap = parseOptionalInt(process.env.FOLLOWERS_QUEUE_CAP);
      this.followersQueue = new Queue('follower', {
        pushedCap: pushedCap,
        queueCap: queueCap
      });
      pushedCap = parseOptionalInt(process.env.FRIENDS_PUSHED_CAP);
      queueCap = parseOptionalInt(process.env.FRIENDS_QUEUE_CAP);
      this.friendsQueue = new Queue('friend', {
        pushedCap: pushedCap,
        queueCap: queueCap
      });
      this.usersLookupLimit = rateLimiter();
      this.followersIdsLimit = rateLimiter();
      this.friendsIdsLimit = rateLimiter();
      this.redis = createRedisClient();
    }

    Surveyer.prototype.seed = function*() {
      return (yield this.userQueue.push(237845487));
    };

    Surveyer.prototype.stats = function*() {
      return {
        user: (yield this.userQueue.stats()),
        followers: (yield this.followersQueue.stats()),
        friends: (yield this.friendsQueue.stats()),
        influencers: (yield this.redis.zcard('influence')),
        lastInfluencer: (yield (function(_this) {
          return function*() {
            var influencer;
            influencer = (yield _this.redis.get('lastinfluencer'));
            return JSON.parse(influencer || 'null');
          };
        })(this))
      };
    };

    Surveyer.prototype.users = function*() {
      var followedIds, followers_count, i, id, j, k, lastInfluencer, len, ref, results, screen_name, user, userBrief, users;
      assert(this.twitter);
      results = [];
      while (true) {
        followedIds = [(yield this.userQueue.pop())];
        (yield (function(cb) {
          return setTimeout(cb, 100);
        }));
        for (i = j = 1; j < 100; i = ++j) {
          id = (yield this.userQueue.pop(0));
          if (!id) {
            break;
          }
          followedIds.push(id);
        }
        users = (yield this.usersLookupLimit((function(_this) {
          return function(cb) {
            return _this.twitter.get('users/lookup', {
              user_id: followedIds.join(',')
            }, cb);
          };
        })(this)))[0];
        ref = users || [];
        for (k = 0, len = ref.length; k < len; k++) {
          user = ref[k];
          followers_count = user.followers_count, screen_name = user.screen_name, id = user.id;
          if (followers_count >= influential) {
            (yield this.redis.zadd('influence', followers_count, screen_name));
            userBrief = {
              name: user.name,
              followers_count: user.followers_count,
              description: user.description,
              location: user.location,
              url: user.url
            };
            (yield this.redis.hset('influencers', screen_name, JSON.stringify(userBrief)));
            (yield this.followersQueue.push(id));
            lastInfluencer = user;
          }
        }
        if (lastInfluencer) {
          results.push((yield this.redis.set('lastinfluencer', JSON.stringify(lastInfluencer))));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    Surveyer.prototype.followers = function*() {
      var follower, id, ids, results;
      assert(this.twitter);
      results = [];
      while (true) {
        id = (yield this.followersQueue.pop());
        ids = (yield this.followersIdsLimit((function(_this) {
          return function(cb) {
            return _this.twitter.get('followers/ids', {
              user_id: id,
              count: 5000
            }, cb);
          };
        })(this)))[0].ids;
        results.push((yield* (function*() {
          var j, len, ref, results1;
          ref = ids || [];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            follower = ref[j];
            (yield this.userQueue.push(follower));
            results1.push((yield this.friendsQueue.push(follower)));
          }
          return results1;
        }).call(this)));
      }
      return results;
    };

    Surveyer.prototype.friends = function*() {
      var friend, id, ids, results;
      assert(this.twitter);
      results = [];
      while (true) {
        id = (yield this.friendsQueue.pop());
        ids = (yield this.friendsIdsLimit((function(_this) {
          return function(cb) {
            return _this.twitter.get('friends/ids', {
              user_id: id,
              count: 5000
            }, cb);
          };
        })(this)))[0].ids;
        results.push((yield* (function*() {
          var j, len, ref, results1;
          ref = ids || [];
          results1 = [];
          for (j = 0, len = ref.length; j < len; j++) {
            friend = ref[j];
            results1.push((yield this.userQueue.push(friend)));
          }
          return results1;
        }).call(this)));
      }
      return results;
    };

    return Surveyer;

  })();

  authenticate = function(consumer_key, consumer_secret) {
    return new Twit({
      consumer_key: consumer_key,
      consumer_secret: consumer_secret,
      app_only_auth: true
    });
  };

  start = function*() {
    var TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET, chainError, credential, credentialCount, credentials, j, key, len, redisClient, ref, ref1, ref2, secret, surveyer, twitter;
    credentials = {};
    ref = process.env, TWITTER_CONSUMER_KEY = ref.TWITTER_CONSUMER_KEY, TWITTER_CONSUMER_SECRET = ref.TWITTER_CONSUMER_SECRET;
    if (TWITTER_CONSUMER_KEY) {
      credentials[TWITTER_CONSUMER_KEY] = TWITTER_CONSUMER_SECRET;
    }
    redisClient = createRedisClient();
    ref1 = (yield redisClient.lrange('credentials', 0, -1));
    for (j = 0, len = ref1.length; j < len; j++) {
      credential = ref1[j];
      ref2 = credential.split(':'), key = ref2[0], secret = ref2[1];
      if (key === TWITTER_CONSUMER_KEY) {
        continue;
      }
      credentials[key] = secret;
    }
    redisClient.quit();
    credentialCount = 0;
    for (key in credentials) {
      secret = credentials[key];
      twitter = authenticate(key, secret);
      surveyer = new Surveyer(twitter);
      (yield surveyer.seed());
      chainError = function(err) {
        return setImmediate(function() {
          throw err;
        });
      };
      co(surveyer.users)["catch"](chainError);
      co(surveyer.followers)["catch"](chainError);
      co(surveyer.friends)["catch"](chainError);
      ++credentialCount;
    }
    return console.log(credentialCount + " Twitter app credential(s) in use");
  };

  if (require.main === module) {
    co(start)["catch"](function(err) {
      return console.error(err.stack);
    });
  }

  module.exports = {
    start: start,
    createRedisClient: createRedisClient,
    Queue: Queue,
    Surveyer: Surveyer
  };

}).call(this);
